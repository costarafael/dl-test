{"version":3,"file":"dateHelpers-C52cMW5X.js","sources":["../../node_modules/date-fns/differenceInDays.js","../../node_modules/date-fns/isBefore.js","../../src/utils/dateHelpers.ts"],"sourcesContent":["import { normalizeDates } from \"./_lib/normalizeDates.js\";\nimport { differenceInCalendarDays } from \"./differenceInCalendarDays.js\";\n\n/**\n * The {@link differenceInDays} function options.\n */\n\n/**\n * @name differenceInDays\n * @category Day Helpers\n * @summary Get the number of full days between the given dates.\n *\n * @description\n * Get the number of full day periods between two dates. Fractional days are\n * truncated towards zero.\n *\n * One \"full day\" is the distance between a local time in one day to the same\n * local time on the next or previous day. A full day can sometimes be less than\n * or more than 24 hours if a daylight savings change happens between two dates.\n *\n * To ignore DST and only measure exact 24-hour periods, use this instead:\n * `Math.trunc(differenceInHours(dateLeft, dateRight)/24)|0`.\n *\n * @param laterDate - The later date\n * @param earlierDate - The earlier date\n * @param options - An object with options\n *\n * @returns The number of full days according to the local timezone\n *\n * @example\n * // How many full days are between\n * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?\n * const result = differenceInDays(\n *   new Date(2012, 6, 2, 0, 0),\n *   new Date(2011, 6, 2, 23, 0)\n * )\n * //=> 365\n *\n * @example\n * // How many full days are between\n * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?\n * const result = differenceInDays(\n *   new Date(2011, 6, 3, 0, 1),\n *   new Date(2011, 6, 2, 23, 59)\n * )\n * //=> 0\n *\n * @example\n * // How many full days are between\n * // 1 March 2020 0:00 and 1 June 2020 0:00 ?\n * // Note: because local time is used, the\n * // result will always be 92 days, even in\n * // time zones where DST starts and the\n * // period has only 92*24-1 hours.\n * const result = differenceInDays(\n *   new Date(2020, 5, 1),\n *   new Date(2020, 2, 1)\n * )\n * //=> 92\n */\nexport function differenceInDays(laterDate, earlierDate, options) {\n  const [laterDate_, earlierDate_] = normalizeDates(\n    options?.in,\n    laterDate,\n    earlierDate,\n  );\n\n  const sign = compareLocalAsc(laterDate_, earlierDate_);\n  const difference = Math.abs(\n    differenceInCalendarDays(laterDate_, earlierDate_),\n  );\n\n  laterDate_.setDate(laterDate_.getDate() - sign * difference);\n\n  // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full\n  // If so, result must be decreased by 1 in absolute value\n  const isLastDayNotFull = Number(\n    compareLocalAsc(laterDate_, earlierDate_) === -sign,\n  );\n\n  const result = sign * (difference - isLastDayNotFull);\n  // Prevent negative zero\n  return result === 0 ? 0 : result;\n}\n\n// Like `compareAsc` but uses local time not UTC, which is needed\n// for accurate equality comparisons of UTC timestamps that end up\n// having the same representation in local time, e.g. one hour before\n// DST ends vs. the instant that DST ends.\nfunction compareLocalAsc(laterDate, earlierDate) {\n  const diff =\n    laterDate.getFullYear() - earlierDate.getFullYear() ||\n    laterDate.getMonth() - earlierDate.getMonth() ||\n    laterDate.getDate() - earlierDate.getDate() ||\n    laterDate.getHours() - earlierDate.getHours() ||\n    laterDate.getMinutes() - earlierDate.getMinutes() ||\n    laterDate.getSeconds() - earlierDate.getSeconds() ||\n    laterDate.getMilliseconds() - earlierDate.getMilliseconds();\n\n  if (diff < 0) return -1;\n  if (diff > 0) return 1;\n\n  // Return 0 if diff is 0; return NaN if diff is NaN\n  return diff;\n}\n\n// Fallback for modularized imports:\nexport default differenceInDays;\n","import { toDate } from \"./toDate.js\";\n\n/**\n * @name isBefore\n * @category Common Helpers\n * @summary Is the first date before the second one?\n *\n * @description\n * Is the first date before the second one?\n *\n * @param date - The date that should be before the other one to return true\n * @param dateToCompare - The date to compare with\n *\n * @returns The first date is before the second date\n *\n * @example\n * // Is 10 July 1989 before 11 February 1987?\n * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))\n * //=> false\n */\nexport function isBefore(date, dateToCompare) {\n  return +toDate(date) < +toDate(dateToCompare);\n}\n\n// Fallback for modularized imports:\nexport default isBefore;\n","import { format, differenceInDays, isAfter, isBefore } from 'date-fns';\n\n// Formatar data no padrão brasileiro\nexport const formatarData = (data: Date | string | null | undefined, defaultValue = ''): string => {\n  if (!data) return defaultValue;\n  \n  try {\n    const date = typeof data === 'string' ? new Date(data) : data;\n    return format(date, 'dd/MM/yyyy');\n  } catch (error) {\n    console.warn('Erro ao formatar data:', data, error);\n    return defaultValue;\n  }\n};\n\n// Formatar data e hora no padrão brasileiro\nexport const formatarDataHora = (data: Date | string | null | undefined, defaultValue = ''): string => {\n  if (!data) return defaultValue;\n  \n  try {\n    const date = typeof data === 'string' ? new Date(data) : data;\n    return format(date, 'dd/MM/yyyy HH:mm');\n  } catch (error) {\n    console.warn('Erro ao formatar data e hora:', data, error);\n    return defaultValue;\n  }\n};\n\n// Formatar apenas hora\nexport const formatarHora = (data: Date | string | null | undefined, defaultValue = ''): string => {\n  if (!data) return defaultValue;\n  \n  try {\n    const date = typeof data === 'string' ? new Date(data) : data;\n    return format(date, 'HH:mm');\n  } catch (error) {\n    console.warn('Erro ao formatar hora:', data, error);\n    return defaultValue;\n  }\n};\n\n// Verificar se uma data está vencida\nexport const isDataVencida = (dataValidade: Date | string | null | undefined): boolean => {\n  if (!dataValidade) return false;\n  \n  try {\n    const date = typeof dataValidade === 'string' ? new Date(dataValidade) : dataValidade;\n    return isBefore(date, new Date());\n  } catch (error) {\n    console.warn('Erro ao verificar vencimento:', dataValidade, error);\n    return false;\n  }\n};\n\n// Verificar se uma data está próxima do vencimento\nexport const isProximoVencimento = (dataValidade: Date | string | null | undefined, diasAlerta = 30): boolean => {\n  if (!dataValidade) return false;\n  \n  try {\n    const date = typeof dataValidade === 'string' ? new Date(dataValidade) : dataValidade;\n    const hoje = new Date();\n    const diasParaVencer = differenceInDays(date, hoje);\n    \n    return diasParaVencer <= diasAlerta && diasParaVencer > 0;\n  } catch (error) {\n    console.warn('Erro ao verificar proximidade do vencimento:', dataValidade, error);\n    return false;\n  }\n};\n\n// Calcular dias restantes até o vencimento\nexport const diasParaVencimento = (dataValidade: Date | string | null | undefined): number => {\n  if (!dataValidade) return 0;\n  \n  try {\n    const date = typeof dataValidade === 'string' ? new Date(dataValidade) : dataValidade;\n    return Math.max(0, differenceInDays(date, new Date()));\n  } catch (error) {\n    console.warn('Erro ao calcular dias para vencimento:', dataValidade, error);\n    return 0;\n  }\n};\n\n// Calcular idade de uma data (em dias)\nexport const calcularIdadeDias = (dataInicio: Date | string | null | undefined): number => {\n  if (!dataInicio) return 0;\n  \n  try {\n    const date = typeof dataInicio === 'string' ? new Date(dataInicio) : dataInicio;\n    return differenceInDays(new Date(), date);\n  } catch (error) {\n    console.warn('Erro ao calcular idade em dias:', dataInicio, error);\n    return 0;\n  }\n};\n\n// Formatar período relativo (ex: \"há 2 dias\", \"em 5 dias\")\nexport const formatarPeriodoRelativo = (data: Date | string | null | undefined): string => {\n  if (!data) return '';\n  \n  try {\n    const date = typeof data === 'string' ? new Date(data) : data;\n    const hoje = new Date();\n    const dias = differenceInDays(date, hoje);\n    \n    if (dias === 0) return 'hoje';\n    if (dias === 1) return 'amanhã';\n    if (dias === -1) return 'ontem';\n    if (dias > 0) return `em ${dias} dias`;\n    return `há ${Math.abs(dias)} dias`;\n  } catch (error) {\n    console.warn('Erro ao formatar período relativo:', data, error);\n    return '';\n  }\n};\n\n// Verificar se uma data está dentro de um período\nexport const isDataNoPeriodo = (\n  data: Date | string | null | undefined,\n  dataInicio: Date | string | null | undefined,\n  dataFim: Date | string | null | undefined\n): boolean => {\n  if (!data || !dataInicio || !dataFim) return false;\n  \n  try {\n    const date = typeof data === 'string' ? new Date(data) : data;\n    const inicio = typeof dataInicio === 'string' ? new Date(dataInicio) : dataInicio;\n    const fim = typeof dataFim === 'string' ? new Date(dataFim) : dataFim;\n    \n    return !isBefore(date, inicio) && !isAfter(date, fim);\n  } catch (error) {\n    console.warn('Erro ao verificar data no período:', data, dataInicio, dataFim, error);\n    return false;\n  }\n};"],"names":["differenceInDays","laterDate","earlierDate","options","laterDate_","earlierDate_","normalizeDates","sign","compareLocalAsc","difference","differenceInCalendarDays","isLastDayNotFull","result","diff","isBefore","date","dateToCompare","toDate","formatarData","data","defaultValue","format","error","isDataVencida","dataValidade","isProximoVencimento","diasAlerta","diasParaVencer"],"mappings":"8DA4DO,SAASA,EAAiBC,EAAWC,EAAaC,EAAS,CAChE,KAAM,CAACC,EAAYC,CAAY,EAAIC,EACjCH,GAAA,YAAAA,EAAS,GACTF,EACAC,CACD,EAEKK,EAAOC,EAAgBJ,EAAYC,CAAY,EAC/CI,EAAa,KAAK,IACtBC,EAAyBN,EAAYC,CAAY,CAClD,EAEDD,EAAW,QAAQA,EAAW,QAAO,EAAKG,EAAOE,CAAU,EAI3D,MAAME,EAAmB,EACvBH,EAAgBJ,EAAYC,CAAY,IAAM,CAACE,GAG3CK,EAASL,GAAQE,EAAaE,GAEpC,OAAOC,IAAW,EAAI,EAAIA,CAC5B,CAMA,SAASJ,EAAgBP,EAAWC,EAAa,CAC/C,MAAMW,EACJZ,EAAU,YAAW,EAAKC,EAAY,YAAa,GACnDD,EAAU,SAAQ,EAAKC,EAAY,SAAU,GAC7CD,EAAU,QAAO,EAAKC,EAAY,QAAS,GAC3CD,EAAU,SAAQ,EAAKC,EAAY,SAAU,GAC7CD,EAAU,WAAU,EAAKC,EAAY,WAAY,GACjDD,EAAU,WAAU,EAAKC,EAAY,WAAY,GACjDD,EAAU,gBAAe,EAAKC,EAAY,gBAAiB,EAE7D,OAAIW,EAAO,EAAU,GACjBA,EAAO,EAAU,EAGdA,CACT,CCpFO,SAASC,EAASC,EAAMC,EAAe,CAC5C,MAAO,CAACC,EAAOF,CAAI,EAAI,CAACE,EAAOD,CAAa,CAC9C,CCnBO,MAAME,EAAe,CAACC,EAAwCC,EAAe,KAAe,CAC7F,GAAA,CAACD,EAAa,OAAAC,EAEd,GAAA,CACF,MAAML,EAAO,OAAOI,GAAS,SAAW,IAAI,KAAKA,CAAI,EAAIA,EAClD,OAAAE,EAAON,EAAM,YAAY,QACzBO,EAAO,CACN,eAAA,KAAK,yBAA0BH,EAAMG,CAAK,EAC3CF,CAAA,CAEX,EA6BaG,EAAiBC,GAA4D,CACpF,GAAA,CAACA,EAAqB,MAAA,GAEtB,GAAA,CACF,MAAMT,EAAO,OAAOS,GAAiB,SAAW,IAAI,KAAKA,CAAY,EAAIA,EACzE,OAAOV,EAASC,EAAU,IAAA,IAAM,QACzBO,EAAO,CACN,eAAA,KAAK,gCAAiCE,EAAcF,CAAK,EAC1D,EAAA,CAEX,EAGaG,EAAsB,CAACD,EAAgDE,EAAa,KAAgB,CAC3G,GAAA,CAACF,EAAqB,MAAA,GAEtB,GAAA,CACF,MAAMT,EAAO,OAAOS,GAAiB,SAAW,IAAI,KAAKA,CAAY,EAAIA,EAEnEG,EAAiB3B,EAAiBe,MADvB,IACiC,EAE3C,OAAAY,GAAkBD,GAAcC,EAAiB,QACjDL,EAAO,CACN,eAAA,KAAK,+CAAgDE,EAAcF,CAAK,EACzE,EAAA,CAEX","x_google_ignoreList":[0,1]}